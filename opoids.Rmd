---
title: "opoids"
author: "kexin wang"
date: "3/26/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE)
```

```{r,warning = F}
library(readxl)
library(devtools)
library(usethis)
library(tidyverse)
library(openintro)
library(arcos)
library(ggiraph)
library(ggpubr)
library(ggfortify)
```


#gather the data about the amount of the two drugs(oxy and hydrocodone)

DRUG_NAME, DOSAGE_UNIT,dos_str


We have to use summarise function, and these two are useful function, others may provide pills for each pharmacy in a county but not what we need.

```{r}
summarized_county_annual(county = "Mingo", state = "WV",key = "WaPo") %>%
  select(FIPS = countyfips, STATE = BUYER_STATE, COUNTY = BUYER_COUNTY,DOSAGE_UNIT)
#summarized_county_monthly(county = "Mingo", state = "WV",key = "WaPo")  #300 thousand
```

Get annual total pills for each buyer (pharmacy, etc) in a county

```{r}
dfarcos <- county_list(key = "WaPo") 
dim(dfarcos)
```


```{r}
getDrug <- function(s,c){
  s = toString(s)
  c = toString(c)  
  data = summarized_county_annual(county = c, state = s, key = "WaPo")
  if (!length(data) == 0 ){
     data %>% select(FIPS = countyfips, YEAR = year, STATE = BUYER_STATE, COUNTY = BUYER_COUNTY,DOSAGE_UNIT)

  }

}
```

ignore such county without information

```{r}
summarized_county_annual(county = "DOLORES", state = "CO", key = "WaPo")
```


# annual_data

```{r}
temp1 <- dfarcos$BUYER_STATE[1:1000]
temp2 <- dfarcos$BUYER_COUNTY[1:1000]

df1 <- map2_dfr(temp1,temp2,function(x,y){getDrug(x,y)})
```

```{r}
temp1 <- dfarcos$BUYER_STATE[1001:3143]
temp2 <- dfarcos$BUYER_COUNTY[1001:3143]

#typeof(summarized_county_annual(county = "DOLORES", state = "CO", key = "WaPo"))
df2 <- map2_dfr(temp1,temp2,function(x,y){getDrug(x,y)})
```
```{r}
#rbind(df1,df2) %>% mutate( FIPS = str_remove(FIPS, "^0+"))
write.csv(rbind(df1,df2) %>% mutate( FIPS = str_remove(FIPS, "^0+")),'annual_dosage_unit.csv')

```

```{r}
dfAnnualDosage <- read.csv('annual_dosage_unit.csv', header=TRUE, row.names=1)
```


# Analysis of annual data


```{r}
dfPop <- read.csv('population.csv', header=TRUE,row.names = 1)



dfAnnual <- dfPop  %>% left_join(dfAnnualDosage[, c('FIPS','YEAR','DOSAGE_UNIT')], by='FIPS' ) %>% 
  filter(!is.na(YEAR))  %>% mutate_each_(funs(factor(.)),
               c('FIPS','YEAR','Urban10','Urban06','Urban13'))



dfAnnual 
```


# Normalization
```{r}
read.csv('2010.csv', header=TRUE)  %>% slice(2:n()) %>% 
  mutate(FIPS = str_sub(GEO_ID, -4,-1)) %>% 
  select(FIPS, NAME, POP = B01003_001E)



```



```{r}
read_pop <- function(file){
  read.csv( file, header=TRUE) %>% slice(2:n()) %>% 
  mutate(FIPS = str_sub(GEO_ID, -4,-1)) %>% 
  select(FIPS, POP = B01003_001E)
}

cbind.na(read_pop('2010.csv'), read_pop('2013.csv'))
read_pop('2010.csv')
read_pop('2013.csv')
```




# EDA.1 Across year

Normalize data

```{r}
df1 <- dfAnnual %>% group_by(Urban10) %>%
  mutate( norm1DOSAGE_UNIT = (DOSAGE_UNIT-min(DOSAGE_UNIT))/(max(DOSAGE_UNIT)-min(DOSAGE_UNIT)))

df11 <- dfAnnual %>% 
  mutate( norm2DOSAGE_UNIT = DOSAGE_UNIT/DENS)

```


The mean of the series should not be a function of time rather should be a constant.
Box plot across yeras will give us a sense on annual trend.


why we need normalization? From the plot we can see without normalization, data
are squished. 

```{r, fig.height = 5, fig.width=10}
p1 <- ggplot(df1, aes(x = YEAR, y = DOSAGE_UNIT, colour = YEAR)) + 
  geom_boxplot()+ 
  labs(title = "Without Normalization")+
  theme_minimal()


p2 <- ggplot(df1, aes(x = YEAR, y = norm1DOSAGE_UNIT, colour = YEAR)) + 
  geom_boxplot()+ 
  labs(title = "U-R Normalization")+
  theme_minimal()

p3 <- ggplot(df11, aes(x = YEAR, y = log10(norm2DOSAGE_UNIT), colour = YEAR)) + 
  geom_boxplot()+ 
  labs(title = "Density Normalization & Log Transformation")+
  theme_minimal()

ggarrange(p1, p2, p3,ncol=3)

```

## Across state

```{r, fig.width=5, fig.height = 6}
#ggplot(df1, aes(x=YEAR, y=normDOSAGE_UNIT, color=STATE)) + 
#  stat_summary(aes(group = STATE), fun.y = mean, geom = 'line', alpha=0.9) +
# theme_bw()

df2 <- df1  %>%
     group_by(STATE,YEAR) %>%
     summarise(normDOSAGE_UNIT = mean(norm1DOSAGE_UNIT))


p3 <- ggplot(df2, aes(x = YEAR, y = normDOSAGE_UNIT, color = STATE)) + 
  geom_line_interactive(aes(group=STATE, 
          data_id = STATE, tooltip = STATE), show.legend = FALSE)+
  labs(title = "Mean Dosage Amount Across State")+
  theme_minimal()



girafe(code = print(p3) )
```




## Focus on 2006,2010,2013


This plot further indicates the importance of normalization
as in the left plot, mean of dosuage in rural
area actually has a big change. But because of its 
original scale, this change is not obvious. The goal of 
normalization is to make every datapoint have the same 
scale so each feature is equally important. 


Min-max normalization: Guarantees all features will 
have the exact same scale but does not handle outliers well.

Z-score normalization: Handles outliers, but does not 
produce normalized data with the exact same scale.


Analysis of patient opioid prescription data from 
a national electronic health record vendor during 2014â€“2017
found that the percentage of patients prescribed an opioid 
was higher in rural than in urban areas. 

```{r, fig.width=12, fig.height=6}


df3 <- df1  %>% filter(YEAR %in% c('2010', '2006','2013'))
df11 <- df11%>% filter(YEAR %in% c('2010', '2006','2013'))



MaxMinNorm <- function(df){
    
      df[df$YEAR=='2006',] <- df[df$YEAR=='2006',] %>% group_by(Urban06) %>%
  mutate( norm1DOSAGE_UNIT = (DOSAGE_UNIT-min(DOSAGE_UNIT))/(max(DOSAGE_UNIT)-min(DOSAGE_UNIT)))

      df[df$YEAR=='2013',] <- df[df$YEAR=='2013',]  %>% group_by(Urban13) %>%
  mutate( norm1DOSAGE_UNIT = (DOSAGE_UNIT-min(DOSAGE_UNIT))/(max(DOSAGE_UNIT)-min(DOSAGE_UNIT)))
      
      return(df)

}

df33 <- MaxMinNorm(df3)



summary(cbind(df3[df3$YEAR=='2006','norm1DOSAGE_UNIT'], df33[df33$YEAR=='2006','norm1DOSAGE_UNIT']))
summary(cbind(df3[df3$YEAR=='2010','norm1DOSAGE_UNIT'], df33[df33$YEAR=='2010','norm1DOSAGE_UNIT']))
summary(cbind(df3[df3$YEAR=='2013','norm1DOSAGE_UNIT'], df33[df33$YEAR=='2013','norm1DOSAGE_UNIT']))
```


```{r, fig.width=12, fig.height=6}

p4 <- ggplot(df3, aes(y = DOSAGE_UNIT, x = YEAR, colour = Urban10, group = Urban10)) + 
  stat_summary(fun.y = mean,
               fun.ymin = function(x) mean(x) - sd(x), 
               fun.ymax = function(x) mean(x) + sd(x), 
               geom = "pointrange") +
  stat_summary(fun.y = mean,
               geom = "line") +
  facet_wrap( ~ Urban10) +
  labs(title = "Dosage Amount Change Without Normalization")+
  theme_minimal()


p5 <- ggplot(df3, aes(y = norm1DOSAGE_UNIT, x = YEAR, colour = Urban10, group = Urban10)) + 
  stat_summary(fun.y = mean,
               fun.ymin = function(x) mean(x) - sd(x), 
               fun.ymax = function(x) mean(x) + sd(x), 
               geom = "pointrange") +
  stat_summary(fun.y = mean,
               geom = "line") +
  facet_wrap( ~ Urban10) +
  labs(title = "Dosage Amount Change With Normalization")+
  theme_minimal()



p55 <- ggplot(df11, aes(y = log(norm2DOSAGE_UNIT), x = YEAR, colour = Urban10, group = Urban10)) + 
  stat_summary(fun.y = mean,
               fun.ymin = function(x) mean(x) - sd(x), 
               fun.ymax = function(x) mean(x) + sd(x), 
               geom = "pointrange") +
  stat_summary(fun.y = mean,
               geom = "line") +
  facet_wrap( ~ Urban10) +
  labs(title = "Dosage Amount Change With DENS Normalization")+
  theme_minimal()

ggarrange(p4, p5, p55, ncol=3)

```


